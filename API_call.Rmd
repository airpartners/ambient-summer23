---
title: "API Call"
author: "Cherry Pham"
date: "2023-06-20"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

This Markdown file is created with the purpose of obtaining sensor data
from Quant-AQ through API calls.

There is no prerequisites for using this file. If you are just looking
to quickly retrieve data, you can simply run this file through the
command `Ctrl + Alt + R`. The result of running this file is a data
folder containing data of MOD-PM sensors as of February 2023. If you
wish to modify the data to be retrieved, please read the data guide
below.

## DATA GUIDE

[write instructions here]

[sorry if i forgot to do this at the end, the code below is quite well
documented though so good luck]

## PACKAGES AND INITIAL SETTINGS

```{r}
# Check and install required packages if necessary
packages <- c("httr", "jsonlite", "purrr", "dplyr")
install.packages(packages[!sapply(packages, requireNamespace, quietly = TRUE)])

# Load required packages
invisible(sapply(packages, library, character.only = TRUE))

# Explicit package function calls
httr::GET
httr::content
jsonlite::fromJSON
purrr::map_df
dplyr::as_data_frame
dplyr::filter
dplyr::lag

# Set options
knitr::opts_chunk$set(echo = FALSE, message = FALSE)
```

## DEFINE VARIABLES

```{r}
base_url <- "https://api.quant-aq.com/device-api/v1/devices/"
api_key <- "VUOLNUDTM70QZ7Z9G0Z78XA7"

# Define a time range to loop over until I find a better way
time_range <-
  seq(as.Date("2022-07-19"), as.Date("2022-09-30"), by = "day")
time_range <- format(time_range, "%Y-%m-%d")

# Define a list of device IDs
device_ids <- c(
  "MOD-00024",
  "MOD-00025",
  "MOD-00026",
  "MOD-00027",
  "MOD-00028",
  "MOD-PM-00141",
  "MOD-PM-00211",
  "MOD-PM-00212",
  "MOD-PM-00213",
  "MOD-PM-00214",
  "MOD-PM-00216",
  "MOD-PM-00217",
  "MOD-PM-00221",
  "MOD-PM-00222",
  "MOD-PM-00224",
  "MOD-PM-00226",
  "MOD-PM-00230",
  "MOD-PM-00231"
)
```

## RETTRIEVING DATA INTO FOLDERS

```{r}
# Create folder if not initiated
data_folder_path <- "./data/Quant-AQ/MOD-PM"

# Check if the folder exists
if (!file.exists(data_folder_path)) {
  # Create the folder if it doesn't exist
  dir.create(data_folder_path, recursive = TRUE)
}

# Function to process a single device ID
process_device_id <- function(device_id, date, state) {
  # Construct device URL for API call
  device_url <- paste0(device_id, "/data-by-date/",state, date, "/")

  # Send GET request
  raw_data <- GET(
    url = paste0(base_url, device_url),
    authenticate(api_key, "", type = "basic"),
    encoding = "UTF-8"
  )
  
  # Option 1: Un-comment this if you want to just ignore the faulty API responses
  # Check the HTTP status code of the response
  if (status_code(raw_data) != 200) {
    # Skip processing if the response is not successful (not 200)
    return()
  }

  # # Option 2: Un-comment this if you want to see the faulty API responses in error_log.txt
  # # Check the content type of the response
  # content_type <- httr::headers(raw_data)$`content-type`
  # if (!grepl("application/json", content_type, ignore.case = TRUE)) {
  #   # Handle the error
  #   error_msg <-
  #     paste0("Error: Unexpected content type for", device_id, "on", date)
  #   # Store the raw response or handle it as needed
  #   raw_response <-
  #     content(raw_data, as = "text", encoding = "UTF-8")
  #   
  #   # Write the error message and raw response to a log file
  #   log_entry <- paste0(error_msg, "\n", raw_response, "\n\n")
  #   write(log_entry, file = "error_log.txt", append = TRUE)
  #   
  #   return()
  # }
  
  data <- content(raw_data, as = "text", encoding = "UTF-8")
  parsed_data <- fromJSON(data)
  
  # Check if the data is empty or has zero rows
  if (is.null(parsed_data) ||
      is.null(parsed_data$data) || length(parsed_data$data) == 0) {
    # Skip processing if the data is empty
    return()
  }
  
  # Extract relevant data
  df <- as.data.frame(parsed_data$data)
  
  # Define device folder path
  device_folder_path <- file.path(data_folder_path, device_id)
  
  # Check if the device folder exists
  if (!dir.exists(device_folder_path)) {
    # Create the device folder if it doesn't exist
    dir.create(device_folder_path, recursive = TRUE)
  }
  
  # Save data to CSV file
  if (state == "raw/") {
    csv_file_path <-
      file.path(device_folder_path, paste0(device_id, "-", date, "-raw.csv"))
  }
  else {
    csv_file_path <-
      file.path(device_folder_path,
                paste0(device_id, "-", date, "-final.csv"))
  }
  
  # Try writing the CSV file and handle errors
  tryCatch({
    write.csv(df, 
              file = csv_file_path,
              row.names = FALSE,
              fileEncoding = "UTF-8")
  },
  error = function(e) {
    cat(
      paste0("Error writing CSV file for", device_id, "on", date, "\n"),
      file = "error_log.txt",
      append = TRUE
    )
  })
}

# Process each device ID over time range
for (device_id in device_ids) {
  for (date in time_range) {
    for (state in c("raw/", "")) {
      process_device_id(device_id, date, state)
    }
  }
  # Delete the device folder if it is empty
  device_folder_path <- file.path(data_folder_path, device_id)
  if (dir.exists(device_folder_path) &&
      length(list.files(device_folder_path)) == 0) {
    unlink(device_folder_path, recursive = TRUE)
  }
}
```

## VISUALIZING RESULTS

```{r}
# Read CSV file
data_file_path <- "./data/Quant-AQ/MOD-PM/MOD-00024/"
device_SN <- "MOD-00024-a0476092e0f6406f887081af7b1a51c0"
file_path <- paste0(data_file_path, device_SN, ".csv")
str(file_path)
data <- read.csv(file_path)

# Glimpse the data
print(names(data))

data_file_path <- "./data/Quant-AQ/MOD-PM//MOD-00024/"
device_SN <- "MOD-00024-2022-07-19-final"
file_path <- paste0(data_file_path, device_SN, ".csv")
str(file_path)
data2 <- read.csv(file_path)

# Glimpse the data
print(names(data2))
```
